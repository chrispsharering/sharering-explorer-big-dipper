"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _crypto = _interopRequireDefault(require("crypto"));

var _ripemd = _interopRequireDefault(require("ripemd160"));

var _bech = _interopRequireDefault(require("bech32"));

var _helperV = require("./helperV1");

var _helperV2 = require("./helperV2");

var _common = require("./common");

/** ******************************************************************************
 *  (c) 2019 ZondaX GmbH
 *  (c) 2016-2017 Ledger
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing, software
 *  distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions and
 *  limitations under the License.
 ******************************************************************************* */
var CosmosApp =
/*#__PURE__*/
function () {
  function CosmosApp(transport) {
    var scrambleKey = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _common.APP_KEY;
    (0, _classCallCheck2.default)(this, CosmosApp);

    if (!transport) {
      throw new Error("Transport has not been defined");
    }

    this.transport = transport;
    transport.decorateAppAPIMethods(this, ["getVersion", "sign", "getAddressAndPubKey", "appInfo", "deviceInfo", "getBech32FromPK"], scrambleKey);
  }

  (0, _createClass2.default)(CosmosApp, [{
    key: "serializePath",
    value: function serializePath(path) {
      return _regenerator.default.async(function serializePath$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              _context.next = 2;
              return _regenerator.default.awrap((0, _common.getVersion)(this.transport));

            case 2:
              this.versionResponse = _context.sent;

              if (!(this.versionResponse.return_code !== _common.ERROR_CODE.NoError)) {
                _context.next = 5;
                break;
              }

              throw this.versionResponse;

            case 5:
              _context.t0 = this.versionResponse.major;
              _context.next = _context.t0 === 1 ? 8 : _context.t0 === 2 ? 9 : 10;
              break;

            case 8:
              return _context.abrupt("return", (0, _helperV.serializePathv1)(path));

            case 9:
              return _context.abrupt("return", (0, _helperV2.serializePathv2)(path));

            case 10:
              return _context.abrupt("return", {
                return_code: 0x6400,
                error_message: "App Version is not supported"
              });

            case 11:
            case "end":
              return _context.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "signGetChunks",
    value: function signGetChunks(path, message) {
      var serializedPath, chunks, buffer, i, end;
      return _regenerator.default.async(function signGetChunks$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              _context2.next = 2;
              return _regenerator.default.awrap(this.serializePath(path));

            case 2:
              serializedPath = _context2.sent;
              chunks = [];
              chunks.push(serializedPath);
              buffer = Buffer.from(message);

              for (i = 0; i < buffer.length; i += _common.CHUNK_SIZE) {
                end = i + _common.CHUNK_SIZE;

                if (i > buffer.length) {
                  end = buffer.length;
                }

                chunks.push(buffer.slice(i, end));
              }

              return _context2.abrupt("return", chunks);

            case 8:
            case "end":
              return _context2.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "getVersion",
    value: function getVersion() {
      return _regenerator.default.async(function getVersion$(_context3) {
        while (1) {
          switch (_context3.prev = _context3.next) {
            case 0:
              _context3.prev = 0;
              _context3.next = 3;
              return _regenerator.default.awrap((0, _common.getVersion)(this.transport));

            case 3:
              this.versionResponse = _context3.sent;
              return _context3.abrupt("return", this.versionResponse);

            case 7:
              _context3.prev = 7;
              _context3.t0 = _context3["catch"](0);
              return _context3.abrupt("return", (0, _common.processErrorResponse)(_context3.t0));

            case 10:
            case "end":
              return _context3.stop();
          }
        }
      }, null, this, [[0, 7]]);
    }
  }, {
    key: "appInfo",
    value: function appInfo() {
      return _regenerator.default.async(function appInfo$(_context4) {
        while (1) {
          switch (_context4.prev = _context4.next) {
            case 0:
              return _context4.abrupt("return", this.transport.send(0xb0, 0x01, 0, 0).then(function (response) {
                var errorCodeData = response.slice(-2);
                var returnCode = errorCodeData[0] * 256 + errorCodeData[1];
                var result = {};
                var appName = "err";
                var appVersion = "err";
                var flagLen = 0;
                var flagsValue = 0;

                if (response[0] !== 1) {
                  // Ledger responds with format ID 1. There is no spec for any format != 1
                  result.error_message = "response format ID not recognized";
                  result.return_code = 0x9001;
                } else {
                  var appNameLen = response[1];
                  appName = response.slice(2, 2 + appNameLen).toString("ascii");
                  var idx = 2 + appNameLen;
                  var appVersionLen = response[idx];
                  idx += 1;
                  appVersion = response.slice(idx, idx + appVersionLen).toString("ascii");
                  idx += appVersionLen;
                  var appFlagsLen = response[idx];
                  idx += 1;
                  flagLen = appFlagsLen;
                  flagsValue = response[idx];
                }

                return {
                  return_code: returnCode,
                  error_message: (0, _common.errorCodeToString)(returnCode),
                  // //
                  appName: appName,
                  appVersion: appVersion,
                  flagLen: flagLen,
                  flagsValue: flagsValue,
                  // eslint-disable-next-line no-bitwise
                  flag_recovery: (flagsValue & 1) !== 0,
                  // eslint-disable-next-line no-bitwise
                  flag_signed_mcu_code: (flagsValue & 2) !== 0,
                  // eslint-disable-next-line no-bitwise
                  flag_onboarded: (flagsValue & 4) !== 0,
                  // eslint-disable-next-line no-bitwise
                  flag_pin_validated: (flagsValue & 128) !== 0
                };
              }, _common.processErrorResponse));

            case 1:
            case "end":
              return _context4.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "deviceInfo",
    value: function deviceInfo() {
      return _regenerator.default.async(function deviceInfo$(_context5) {
        while (1) {
          switch (_context5.prev = _context5.next) {
            case 0:
              return _context5.abrupt("return", this.transport.send(0xe0, 0x01, 0, 0, Buffer.from([]), [_common.ERROR_CODE.NoError, 0x6e00]).then(function (response) {
                var errorCodeData = response.slice(-2);
                var returnCode = errorCodeData[0] * 256 + errorCodeData[1];

                if (returnCode === 0x6e00) {
                  return {
                    return_code: returnCode,
                    error_message: "This command is only available in the Dashboard"
                  };
                }

                var targetId = response.slice(0, 4).toString("hex");
                var pos = 4;
                var secureElementVersionLen = response[pos];
                pos += 1;
                var seVersion = response.slice(pos, pos + secureElementVersionLen).toString();
                pos += secureElementVersionLen;
                var flagsLen = response[pos];
                pos += 1;
                var flag = response.slice(pos, pos + flagsLen).toString("hex");
                pos += flagsLen;
                var mcuVersionLen = response[pos];
                pos += 1; // Patch issue in mcu version

                var tmp = response.slice(pos, pos + mcuVersionLen);

                if (tmp[mcuVersionLen - 1] === 0) {
                  tmp = response.slice(pos, pos + mcuVersionLen - 1);
                }

                var mcuVersion = tmp.toString();
                return {
                  return_code: returnCode,
                  error_message: (0, _common.errorCodeToString)(returnCode),
                  // //
                  targetId: targetId,
                  seVersion: seVersion,
                  flag: flag,
                  mcuVersion: mcuVersion
                };
              }, _common.processErrorResponse));

            case 1:
            case "end":
              return _context5.stop();
          }
        }
      }, null, this);
    }
  }, {
    key: "publicKey",
    value: function publicKey(path) {
      var serializedPath, data;
      return _regenerator.default.async(function publicKey$(_context6) {
        while (1) {
          switch (_context6.prev = _context6.next) {
            case 0:
              _context6.prev = 0;
              _context6.next = 3;
              return _regenerator.default.awrap(this.serializePath(path));

            case 3:
              serializedPath = _context6.sent;
              _context6.t0 = this.versionResponse.major;
              _context6.next = _context6.t0 === 1 ? 7 : _context6.t0 === 2 ? 8 : 10;
              break;

            case 7:
              return _context6.abrupt("return", (0, _helperV.publicKeyv1)(this, serializedPath));

            case 8:
              data = Buffer.concat([CosmosApp.serializeHRP("cosmos"), serializedPath]);
              return _context6.abrupt("return", (0, _helperV2.publicKeyv2)(this, data));

            case 10:
              return _context6.abrupt("return", {
                return_code: 0x6400,
                error_message: "App Version is not supported"
              });

            case 11:
              _context6.next = 16;
              break;

            case 13:
              _context6.prev = 13;
              _context6.t1 = _context6["catch"](0);
              return _context6.abrupt("return", (0, _common.processErrorResponse)(_context6.t1));

            case 16:
            case "end":
              return _context6.stop();
          }
        }
      }, null, this, [[0, 13]]);
    }
  }, {
    key: "getAddressAndPubKey",
    value: function getAddressAndPubKey(path, hrp) {
      var serializedPath, data;
      return _regenerator.default.async(function getAddressAndPubKey$(_context7) {
        while (1) {
          switch (_context7.prev = _context7.next) {
            case 0:
              _context7.prev = 0;
              _context7.next = 3;
              return _regenerator.default.awrap(this.serializePath(path));

            case 3:
              serializedPath = _context7.sent;
              data = Buffer.concat([CosmosApp.serializeHRP(hrp), serializedPath]);
              return _context7.abrupt("return", this.transport.send(_common.CLA, _common.INS.GET_ADDR_SECP256K1, _common.P1_VALUES.ONLY_RETRIEVE, 0, data, [_common.ERROR_CODE.NoError]).then(function (response) {
                var errorCodeData = response.slice(-2);
                var returnCode = errorCodeData[0] * 256 + errorCodeData[1];
                var compressedPk = Buffer.from(response.slice(0, 33));
                var bech32Address = Buffer.from(response.slice(33, -2)).toString();
                return {
                  bech32_address: bech32Address,
                  compressed_pk: compressedPk,
                  return_code: returnCode,
                  error_message: (0, _common.errorCodeToString)(returnCode)
                };
              }, _common.processErrorResponse));

            case 8:
              _context7.prev = 8;
              _context7.t0 = _context7["catch"](0);
              return _context7.abrupt("return", (0, _common.processErrorResponse)(_context7.t0));

            case 11:
            case "end":
              return _context7.stop();
          }
        }
      }, null, this, [[0, 8]]);
    }
  }, {
    key: "showAddressAndPubKey",
    value: function showAddressAndPubKey(path, hrp) {
      var serializedPath, data;
      return _regenerator.default.async(function showAddressAndPubKey$(_context8) {
        while (1) {
          switch (_context8.prev = _context8.next) {
            case 0:
              _context8.prev = 0;
              _context8.next = 3;
              return _regenerator.default.awrap(this.serializePath(path));

            case 3:
              serializedPath = _context8.sent;
              data = Buffer.concat([CosmosApp.serializeHRP(hrp), serializedPath]);
              return _context8.abrupt("return", this.transport.send(_common.CLA, _common.INS.GET_ADDR_SECP256K1, _common.P1_VALUES.SHOW_ADDRESS_IN_DEVICE, 0, data, [_common.ERROR_CODE.NoError]).then(function (response) {
                var errorCodeData = response.slice(-2);
                var returnCode = errorCodeData[0] * 256 + errorCodeData[1];
                var compressedPk = Buffer.from(response.slice(0, 33));
                var bech32Address = Buffer.from(response.slice(33, -2)).toString();
                return {
                  bech32_address: bech32Address,
                  compressed_pk: compressedPk,
                  return_code: returnCode,
                  error_message: (0, _common.errorCodeToString)(returnCode)
                };
              }, _common.processErrorResponse));

            case 8:
              _context8.prev = 8;
              _context8.t0 = _context8["catch"](0);
              return _context8.abrupt("return", (0, _common.processErrorResponse)(_context8.t0));

            case 11:
            case "end":
              return _context8.stop();
          }
        }
      }, null, this, [[0, 8]]);
    }
  }, {
    key: "signSendChunk",
    value: function signSendChunk(chunkIdx, chunkNum, chunk) {
      return _regenerator.default.async(function signSendChunk$(_context9) {
        while (1) {
          switch (_context9.prev = _context9.next) {
            case 0:
              _context9.prev = 0;
              _context9.t0 = this.versionResponse.major;
              _context9.next = _context9.t0 === 1 ? 4 : _context9.t0 === 2 ? 5 : 6;
              break;

            case 4:
              return _context9.abrupt("return", (0, _helperV.signSendChunkv1)(this, chunkIdx, chunkNum, chunk));

            case 5:
              return _context9.abrupt("return", (0, _helperV2.signSendChunkv2)(this, chunkIdx, chunkNum, chunk));

            case 6:
              return _context9.abrupt("return", {
                return_code: 0x6400,
                error_message: "App Version is not supported"
              });

            case 7:
              _context9.next = 12;
              break;

            case 9:
              _context9.prev = 9;
              _context9.t1 = _context9["catch"](0);
              return _context9.abrupt("return", (0, _common.processErrorResponse)(_context9.t1));

            case 12:
            case "end":
              return _context9.stop();
          }
        }
      }, null, this, [[0, 9]]);
    }
  }, {
    key: "sign",
    value: function sign(path, message) {
      var _this = this;

      var chunks;
      return _regenerator.default.async(function sign$(_context11) {
        while (1) {
          switch (_context11.prev = _context11.next) {
            case 0:
              _context11.prev = 0;
              _context11.next = 3;
              return _regenerator.default.awrap(this.signGetChunks(path, message));

            case 3:
              chunks = _context11.sent;
              return _context11.abrupt("return", this.signSendChunk(1, chunks.length, chunks[0], [_common.ERROR_CODE.NoError]).then(function _callee(response) {
                var result, i;
                return _regenerator.default.async(function _callee$(_context10) {
                  while (1) {
                    switch (_context10.prev = _context10.next) {
                      case 0:
                        result = {
                          return_code: response.return_code,
                          error_message: response.error_message,
                          signature: null
                        };
                        i = 1;

                      case 2:
                        if (!(i < chunks.length)) {
                          _context10.next = 11;
                          break;
                        }

                        _context10.next = 5;
                        return _regenerator.default.awrap(_this.signSendChunk(1 + i, chunks.length, chunks[i]));

                      case 5:
                        result = _context10.sent;

                        if (!(result.return_code !== _common.ERROR_CODE.NoError)) {
                          _context10.next = 8;
                          break;
                        }

                        return _context10.abrupt("break", 11);

                      case 8:
                        i += 1;
                        _context10.next = 2;
                        break;

                      case 11:
                        return _context10.abrupt("return", {
                          return_code: result.return_code,
                          error_message: result.error_message,
                          // ///
                          signature: result.signature
                        });

                      case 12:
                      case "end":
                        return _context10.stop();
                    }
                  }
                });
              }, _common.processErrorResponse));

            case 7:
              _context11.prev = 7;
              _context11.t0 = _context11["catch"](0);
              return _context11.abrupt("return", (0, _common.processErrorResponse)(_context11.t0));

            case 10:
            case "end":
              return _context11.stop();
          }
        }
      }, null, this, [[0, 7]]);
    }
  }], [{
    key: "serializeHRP",
    value: function serializeHRP(hrp) {
      if (hrp == null || hrp.length < 3 || hrp.length > 83) {
        throw new Error("Invalid HRP");
      }

      var buf = Buffer.alloc(1 + hrp.length);
      buf.writeUInt8(hrp.length, 0);
      buf.write(hrp, 1);
      return buf;
    }
  }, {
    key: "getBech32FromPK",
    value: function getBech32FromPK(hrp, pk) {
      if (pk.length !== 33) {
        throw new Error("expected compressed public key [31 bytes]");
      }

      var hashSha256 = _crypto.default.createHash("sha256").update(pk).digest();

      var hashRip = new _ripemd.default().update(hashSha256).digest();
      return _bech.default.encode(hrp, _bech.default.toWords(hashRip));
    }
  }]);
  return CosmosApp;
}();

exports.default = CosmosApp;